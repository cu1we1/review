#### 3.正则表达式中的特殊字符。

- \（反斜杠）

  依照下列规则：

  在**非特殊字符**之前的反斜杠表示下一个字符是特殊字符，不能按照字面理解。例如，前面没有"\"的"b"通常匹配小写字母"b"，即字符会被作为字面理解，无论它出现在哪里。但是如果前端加了反斜杠，它将不再匹配任何字符，而是表示一个**字符边界**。

  在**特殊字符**之前的反斜杠表示下一个字符不是特殊字符，应该按照字面理解。

  如果你想将字符串传递给 RegExp 构造函数，不要忘记在字符串字面量中反斜杠是转义字符。所以为了在模式中添加一个反斜杠，你需要在字符串字面量中转义它。/[a-z]\s/i 和 new RegExp("[a-z]\\s", "i") 创建了相同的正则表达式：一个用于搜索后面紧跟着空白字符（\s 可看后文）并且在 a-z 范围内的任意字符的表达式。

  - ^

  匹配输入的开始。如果修饰符为多行"m"，那么也匹配换行符后紧跟的位置。

  例如，/^A/并不会匹配"an A"中的"A"，但是会匹配"An E"中的"A"。

  当"^"作为第一个字符出现在一个字符集和模式时，它又不同的含义。

  ```js
  let a = `fdsaf 
  A fafa`;

  let regM = /^A/m;
  let regG = /^A/g;

  regM.test(a);
  // true
  regG.test(a);
  // false
  ```

- $

  匹配输入的结束。如果修饰符为多行"m"，那么也匹配换行符前的位置。

- \*

  匹配前一个表达式 0 次或多次。等价于{0,}。

- \+

  匹配前一个表达式 1 次或者多次。等价于{1,}。

- ？

  匹配前面一个表达式 0 次或者 1 次。等价于{0, 1}。

  如果**紧跟在任何量词\*、\+、?或者{}的后面**，将会使量词变为非贪婪（匹配尽量少的字符），和缺省使用的**贪婪**模式（匹配尽可能多的字符）正好相反。例如，对"123abc"使用/\d+/将会匹配"123"，而使用/\d+?/则只会匹配到"1"。

  还可以用于先行断言中。

- .(英文句号)

  默认匹配除换行符之外的任何单个字符。

- (x) 捕获括号

  它会匹配'x'并且记住匹配项。称作**捕获括号**。

- (?:x) 非捕获括号

  匹配'x'但是不记住匹配项。这种括号叫做非捕获括号，使得你可以定义与正则表达式运算符一起使用的子表达式。例如

  ```js
  let reg = /(?:foo){1, 2}/;
  ```

- x(?=y) 先行断言

  匹配'x'，并且仅仅当'x'后面跟着'y'。

  例如：

  ```js
  let reg = /Jack(?=Sprat)/;
  ```

  会匹配到'Jack'仅当它后面跟着'Sprat'。

  ```js
  let reg = /Jack(?=Sprat|Frost)/;
  ```

  匹配'Jack'仅当它后面跟着'Sprat'或者'Frost'。但是'Sprat'和'Frost'都不是匹配结果的一部分。

- (?<=y)x 后行断言

  匹配'x'仅当'x'前面是'y'。

- x(?!y) 正向否定查找

  仅仅当'x'后面不跟着'y'时匹配'x'。

- (?<!y)x 反向否定查找

  仅仅当'x'前面不是'y'时匹配'x'。

- x|y

  匹配'x'或者'y'

- {n}

  n 是一个正整数，匹配前一个字符出现了 n 次。

- {n,}

  n 是一个正整数，匹配前一个字符至少出现了 n 次。

- {n, m}

  n，m 是一个正整数，匹配前一个字符至少出现 n 次，至多出现 m 次。如果都是 0，那么这个值将被忽略。

- [xyz]

  一个字符集合。匹配方括号中的任意字符，包括转义序列。你可以使用破折号（-）来指定一个字符范围。

- [^xyz]

  一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。

- \d

  匹配一个数字。等价于[0-9]

- \D

匹配一个非数字字符。等价于[^0 -9]

- \s

匹配一个空白字符

- \S

匹配一个非空白字符

- \w

匹配一个单字字符（字母、数字或者下划线）。等价于[A-Za-z0-9_]。

- \W

匹配一个非单字字符。等价于[^a-za-z0-9_]。

- \n

在正则表达式中，它返回最后的第 n 个子捕获匹配的子字符串（捕获的数目以左括号计数）。
